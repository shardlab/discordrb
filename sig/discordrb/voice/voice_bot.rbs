# Voice support
module Discordrb::Voice
  # How long one voice packet should ideally be (20ms as defined by Discord)
  IDEAL_LENGTH: ::Float

  # How many bytes of data to read (1920 bytes * 2 channels) from audio PCM data
  DATA_LENGTH: untyped

  # This class represents a connection to a Discord voice server and channel. It can be used to play audio files and
  # streams and to control playback on currently playing tracks. The method {Bot#voice_connect} can be used to connect
  # to a voice channel.
  #
  # discordrb does latency adjustments every now and then to improve playback quality. I made sure to put useful
  # defaults for the adjustment parameters, but if the sound is patchy or too fast (or the speed varies a lot) you
  # should check the parameters and adjust them to your connection: {VoiceBot#adjust_interval},
  # {VoiceBot#adjust_offset}, and {VoiceBot#adjust_average}.
  class VoiceBot
    # @return [Channel] the current voice channel
    attr_reader channel: untyped

    # @!visibility private
    attr_writer channel: untyped

    # @return [Integer, nil] the amount of time the stream has been playing, or `nil` if nothing has been played yet.
    attr_reader stream_time: untyped

    # @return [Encoder] the encoder used to encode audio files into the format required by Discord.
    attr_reader encoder: untyped

    # discordrb will occasionally measure the time it takes to send a packet, and adjust future delay times based
    # on that data. This makes voice playback more smooth, because if packets are sent too slowly, the audio will
    # sound patchy, and if they're sent too quickly, packets will "pile up" and occasionally skip some data or
    # play parts back too fast. How often these measurements should be done depends a lot on the system, and if it's
    # done too quickly, especially on slow connections, the playback speed will vary wildly; if it's done too slowly
    # however, small errors will cause quality problems for a longer time.
    # @return [Integer] how frequently audio length adjustments should be done, in ideal packets (20ms).
    attr_accessor adjust_interval: untyped

    # This particular value is also important because ffmpeg may take longer to process the first few packets. It is
    # recommended to set this to 10 at maximum, otherwise it will take too long to make the first adjustment, but it
    # shouldn't be any higher than {#adjust_interval}, otherwise no adjustments will take place. If {#adjust_interval}
    # is at a value higher than 10, this value should not be changed at all.
    # @see #adjust_interval
    # @return [Integer] the packet number (1 packet = 20ms) at which length adjustments should start.
    attr_accessor adjust_offset: untyped

    # This value determines whether or not the adjustment length should be averaged with the previous value. This may
    # be useful on slower connections where latencies vary a lot. In general, it will make adjustments more smooth,
    # but whether that is desired behaviour should be tried on a case-by-case basis.
    # @see #adjust_interval
    # @return [true, false] whether adjustment lengths should be averaged with the respective previous value.
    attr_accessor adjust_average: untyped

    # Disable the debug message for length adjustment specifically, as it can get quite spammy with very low intervals
    # @see #adjust_interval
    # @return [true, false] whether length adjustment debug messages should be printed
    attr_accessor adjust_debug: untyped

    # If this value is set, no length adjustments will ever be done and this value will always be used as the length
    # (i.e. packets will be sent every N seconds). Be careful not to set it too low as to not spam Discord's servers.
    # The ideal length is 20ms (accessible by the {Discordrb::Voice::IDEAL_LENGTH} constant), this value should be
    # slightly lower than that because encoding + sending takes time. Note that sending DCA files is significantly
    # faster than sending regular audio files (usually about four times as fast), so you might want to set this value
    # to something else if you're sending a DCA file.
    # @return [Float] the packet length that should be used instead of calculating it during the adjustments, in ms.
    attr_accessor length_override: untyped

    # The factor the audio's volume should be multiplied with. `1` is no change in volume, `0` is completely silent,
    # `0.5` is half the default volume and `2` is twice the default.
    # @return [Float] the volume for audio playback, `1.0` by default.
    attr_accessor volume: untyped

    # @!visibility private
    def initialize: (untyped channel, untyped `bot`, untyped token, untyped session, untyped endpoint) -> void

    # @return [true, false] whether audio data sent will be encrypted.
    # @deprecated Discord no longer supports unencrypted voice communication.
    def encrypted?: () -> true

    # Set the filter volume. This volume is applied as a filter for decoded audio data. It has the advantage that using
    # it is much faster than regular volume, but it can only be changed before starting to play something.
    # @param value [Integer] The value to set the volume to. For possible values, see {#volume}
    def filter_volume=: (untyped value) -> untyped

    # @see #filter_volume=
    # @return [Integer] the volume used as a filter for ffmpeg/avconv.
    def filter_volume: () -> untyped

    # Pause playback. This is not instant; it may take up to 20 ms for this change to take effect. (This is usually
    # negligible.)
    def pause: () -> untyped

    # @see #play
    # @return [true, false] Whether it is playing sound or not.
    def playing?: () -> untyped

    alias isplaying? playing?

    # Continue playback. This change may take up to 100ms to take effect, which is usually negligible.
    def continue: () -> untyped

    # Skips to a later time in the song. It's impossible to go back without replaying the song.
    # @param secs [Float] How many seconds to skip forwards. Skipping will always be done in discrete intervals of
    #   0.05 seconds, so if the given amount is smaller than that, it will be rounded up.
    def skip: (untyped secs) -> untyped

    # Sets whether or not the bot is speaking (green circle around user).
    # @param value [true, false, Integer] whether or not the bot should be speaking, or a bitmask denoting the audio type
    # @note https://discord.com/developers/docs/topics/voice-connections#speaking for information on the speaking bitmask
    def speaking=: (untyped value) -> untyped

    # Stops the current playback entirely.
    # @param wait_for_confirmation [true, false] Whether the method should wait for confirmation from the playback
    #   method that the playback has actually stopped.
    def stop_playing: (?bool wait_for_confirmation) -> (nil | untyped)

    # Permanently disconnects from the voice channel; to reconnect you will have to call {Bot#voice_connect} again.
    def destroy: () -> untyped

    # Plays a stream of raw data to the channel. All playback methods are blocking, i.e. they wait for the playback to
    # finish before exiting the method. This doesn't cause a problem if you just use discordrb events/commands to
    # play stuff, as these are fully threaded, but if you don't want this behaviour anyway, be sure to call these
    # methods in separate threads.
    # @param encoded_io [IO] A stream of raw PCM data (s16le)
    def play: (untyped encoded_io) -> untyped

    # Plays an encoded audio file of arbitrary format to the channel.
    # @see Encoder#encode_file
    # @see #play
    def play_file: (untyped file, ?::String options) -> untyped

    # Plays a stream of encoded audio data of arbitrary format to the channel.
    # @see Encoder#encode_io
    # @see #play
    def play_io: (untyped io, ?::String options) -> untyped

    # Plays a stream of audio data in the DCA format. This format has the advantage that no recoding has to be
    # done - the file contains the data exactly as Discord needs it.
    # @note DCA playback will not be affected by the volume modifier ({#volume}) because the modifier operates on raw
    #   PCM, not opus data. Modifying the volume of DCA data would involve decoding it, multiplying the samples and
    #   re-encoding it, which defeats its entire purpose (no recoding).
    # @see https://github.com/bwmarrin/dca
    # @see #play
    def play_dca: (untyped file) -> untyped

    alias play_stream play_io

    private

    # Plays the data from the IO stream as Discord requires it
    def play_internal: () { () -> untyped } -> untyped

    # Increment sequence and time
    def increment_packet_headers: () -> untyped
  end
end
